# 🔐 Project 5: SM2 数字签名算法的软件实现与优化

## 📌 项目目标

本项目聚焦于 SM2 数字签名算法的 Python 实现、优化与安全性验证，结合论文《20250713-wen-sm2-public.pdf》对签名误用场景进行 PoC 复现与漏洞分析，并构造实验性伪造“中本聪”的数字签名。

## 📚 目录

- [项目结构](#项目结构)
- [算法原理](#算法原理)
  - [SM2 签名原理](#sm2-签名原理)
  - [SM2 验证原理](#sm2-验证原理)
- [漏洞分析与公式推导](#漏洞分析与公式推导)
  - [重复使用随机数 k](#重复使用随机数-k)
  - [忽略用户标识 Z](#忽略用户标识-z)
- [PoC 验证与伪造实验](#poc-验证与伪造实验)
- [运行方法](#运行方法)
- [依赖](#依赖)
- [参考资料](#参考资料)

## 📁 项目结构

## 📐 算法原理

### SM2 签名原理

1. 私钥 \\( d \\)，公钥 \\( P = dG \\)，消息 \\( M \\)，用户标识 \\( ID \\)
2. 计算 \\( Z = H(ENTL || ID || a || b || G || P) \\)
3. 计算 \\( e = H(Z || M) \\)
4. 随机选 \\( k \\)，计算 \\( (x_1, y_1) = kG \\)
5. 计算签名：

$$
r = (e + x_1) \mod n \\\\
s = ((1 + d)^{-1} (k - r \cdot d)) \mod n
$$

### SM2 验证原理

验证者根据签名 \\( (r, s) \\)、消息 \\( M \\)、公钥 \\( P \\) 验证：

1. 计算 \\( e = H(Z || M) \\)
2. 验证 \\( (r + s)G = kG = sG + rP \\)，确保椭圆曲线点一致性

## 🔎 漏洞分析与公式推导

### 重复使用随机数 k

若两次签名使用相同 \\( k \\)，且获得两个签名：

$$
s_1 = (1 + d)^{-1}(k - r d) \\\\
s_2 = (1 + d)^{-1}(k - r d)
$$

由此可解出 \\( d \\)，详见 `attack_analysis.md`

### 忽略用户标识 Z

如果开发者错误地只对消息哈希，即：

$$
e = H(M)
$$

则签名容易被转移、复用，无法绑定特定身份。

## 🧪 PoC 验证与伪造实验

- `poc_k_reuse.py`：复用随机数恢复私钥
- `poc_missing_z.py`：未用 Z 导致伪造签名
- `fake_satoshi_signature.py`：构造能通过验证的中本聪伪签名

## 🚀 运行方法

```bash
pip install -r requirements.txt

python demo_basic.py
python poc_k_reuse.py
python fake_satoshi_signature.py
```

## 📦 依赖

* Python 3.8+

* gmssl

* ecdsa

