# Project 5: SM2 数字签名算法的软件实现与优化

## 目录
- [项目背景](#项目背景)
- [实验目标](#实验目标)
- [算法原理](#算法原理)
  - [SM2 签名原理](#sm2-签名原理)
  - [SM2 验证原理](#sm2-验证原理)
- [漏洞分析与公式推导](#漏洞分析与公式推导)
  - [重复使用随机数 k](#重复使用随机数-k)
  - [忽略用户标识 Z](#忽略用户标识-z)
- [PoC 验证与伪造实验](#poc-验证与伪造实验)
- [软件实现与代码说明](#软件实现与代码说明)
- [运行方法](#运行方法)
- [优化方向](#优化方向)
- [依赖](#依赖)
- [参考资料](#参考资料)

---

## 项目背景
SM2 是中国国家密码管理局发布的基于椭圆曲线密码（ECC）的公钥密码算法标准，包含密钥交换、加密和数字签名三部分。本项目专注于 SM2 数字签名的 Python 实现与优化，并复现特定的安全漏洞场景，以加深对算法原理及安全性问题的理解。

---

## 实验目标
1. **理解 SM2 数字签名算法的数学原理**  
   掌握其签名与验证流程，了解在数字签名中的安全意义和应用场景。
2. **Python 实现 SM2 签名算法**  
   完成密钥生成、签名与验签的完整实现，确保与国密标准兼容。
3. **漏洞复现与分析**  
   演示重复使用随机数 \(k\) 和忽略用户标识 \(Z\) 的安全风险，给出数学推导。
4. **验证算法正确性**  
   使用单元测试验证实现的正确性与签名有效性。
5. **探讨优化方向**  
   研究 Python 代码层面和数学计算层面对 SM2 的优化可能。

---

## 算法原理

### SM2 签名原理
1. 设私钥 $d$，公钥 $P = dG$，消息 $M$，用户标识 $ID$。
2. 计算 $Z = H(ENTL || ID || a || b || G || P)$。
3. 计算 $e = H(Z || M)$。
4. 随机选取 $k \in [1, n-1]$，计算 $(x_1, y_1) = kG$。
5. 计算签名：

   $$
   r = (e + x_1) \bmod n
   $$
   
   $$
   s = ((1 + d)^{-1} \cdot (k - r \cdot d)) \bmod n
   $$
   
7. 签名为 $(r, s)$。

### SM2 验证原理
验证者根据签名 $(r, s)$、消息 $M$、公钥 $P$：
1. 计算 $e = H(Z || M)$。
2. 计算 $(x_1', y_1') = sG + rP$。
3. 检查：

   $$
   r \stackrel{?}{=} (e + x_1') \bmod n
   $$

---

## 漏洞分析与公式推导

### 重复使用随机数 k
若两次签名使用相同的随机数 $k$，会得到：

$$
s_1 = (1 + d)^{-1}(k - r_1 d)
$$

$$
s_2 = (1 + d)^{-1}(k - r_2 d)
$$

可联立解出私钥 $d$。

### 忽略用户标识 Z
如果开发者在计算 $e$ 时仅使用：

$$
e = H(M)
$$

而非 $e = H(Z || M)$，则签名可被重放到其他身份下。

---

## PoC 验证与伪造实验
- **`poc_k_reuse.py`**：复用相同随机数恢复私钥。
- **`poc_missing_z.py`**：未绑定 Z 导致的签名跨身份攻击。
- **`fake_satoshi_signature.py`**：构造可验证通过的伪造签名。

---

## 软件实现与代码说明
项目主要代码文件：
- **`sm2.py`**：SM2 核心实现（密钥生成、签名、验签）。
- **`demo_basic.py`**：演示签名与验签。
- **`poc_k_reuse.py`**：k 重复使用攻击复现。
- **`poc_missing_z.py`**：Z 缺失漏洞复现。
- **`fake_satoshi_signature.py`**：伪造签名实验。

---

## 运行方法
```bash
pip install -r requirements.txt

# 基本演示
python demo_basic.py

# 漏洞 PoC
python poc_k_reuse.py
python poc_missing_z.py

# 伪造签名实验
python fake_satoshi_signature.py
